\section{Design Pattern Strutturali}
Sono focalizzati sulle dipendenze degli aggetti affichè abbiano certe
caratteristiche

\subsection{Adapter}
\subsubsection{Scopo}
Consente di adattare l'interfaccia di una libreria esterna (Adaptee) ad
un'interfaccia che mi serve (Target) per poterla usare all'interno del mio
sistema
\subsubsection{Struttura}
Due modi per implementarlo:
\begin{itemize}
    \item \textbf{Adapter di classe}: eredito dalla libreria (Adaptee) e implemento l'interfaccia che mi serve (Target)  in una classe ClassAdapter
    \item \textbf{Adapter di oggetto}: creo un oggetto che implementa l'interfaccia (Target) che mi serve e uso Adaptee come attributo
\end{itemize}
\subsubsection{Problematiche}
Piu metodi da implementare, piu complessità

\subsection{Decorator}
\subsubsection{Scopo}
Aggiungere responsabilità ad un oggetto dinamicamente (senza utilizzo di
ereditarietà). Permette di aggiungere funzioni e funzionalità ad una
funzionalità base.
\subsubsection{Struttura}
\begin{itemize}
    \item \textbf{Component}: interfaccia che definisce l'oggetto base (Pizza)
    \item \textbf{ConcreteComponent}: implementazione dell'interfaccia Component (BasePizza)
    \item \textbf{Decorator}: classe astratta che implementa l'interfaccia Component e ha un attributo di tipo Component (Topped Pizza)
    \item \textbf{ConcreteDecorator}: implementazione di Decorator (Pizze concrete con aggiunte)
\end{itemize}
\subsubsection{Problematiche}
Tante classi molto simili e piccole possono risultare complesse da testare in
isolamento

\subsection{Facade}
\subsubsection{Scopo}
Permette di fornire un'interfaccia unica (accesso semplice) per un sottosistema complesso, ma non
nosconde completamente le funzionalità del sottosistema. Accentra le dipendenze
\subsubsection{Struttura}
\begin{itemize}
    \item \textbf{Facade}: classe che fornisce l'interfaccia unica
    \item \textbf{Subsystem}: classi che implementano le funzionalità del sottosistema
\end{itemize}
\subsubsection{Problematiche}
Da gestire molte dipendenze. Rischio di introdurre bug. Rischio di classe grande. Deve fare un'interfaccia stabile. 

\subsection{Proxy}
\subsubsection{Scopo}
Fornire un oggetto (un altro tipo) sul quale si vogliono fornire caratteristiche ulteriore per l'accesso dei suoi metodi.
\subsubsection{Struttura}
Virtual Proxy: crea oggetti complessi on-demand (quando servono, caricamento in memoria lazy) \\
Remote Proxy: si fa vedere locale un oggetto che in realtà è remoto (sfruttando la rete)\\
Protection Proxy: permetto l'accesso ad alcune funzionalità di alcuni tipi solo a solo a certi utenti (client), fa il controllo dei diritti di accesso\\
Puntatori intelligenti: tengono traccia degli oggetti istanziati\\
\begin{itemize}
    \item \textbf{Subject}: interfaccia che definisce l'oggetto base 
    \item \textbf{RealSubject}: implementazione dell'interfaccia Subject
    \item \textbf{Proxy}: classe che implementa l'interfaccia Subject e ha un attributo di tipo Subject (RealSubject)
\end{itemize}